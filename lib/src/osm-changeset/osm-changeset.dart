import 'package:xml/xml.dart';
import 'package:collection/collection.dart';
import '/src/commons/bounding-box.dart';
import '/src/osm-user/osm-user.dart';
import '/src/osm-changeset/osm-comment.dart';

// temporary workaround untill xml library is updated
extension TempGetChildElements on XmlNode {
  Iterable<XmlElement> get childElements {
    return children.whereType<XmlElement>();
  }
}

/**
 * A container class for an OSM changeset.
 */
class OSMChangeset {

  /**
   * The unique identifier of this changeset.
   *
   * This id is generated by the OSM Server.
   * You shouldn't set the [id] on your own.
   */
  final int id;

  /**
   * A [Map] containing all OSM Tags of this changeset.
   *
   * Each OSM Tag contains and represents one key value pair.
   */
  final Map<String, String> tags;

  /**
   * The date and time the changeset was created.
   */
  final DateTime createdAt;

  /**
   * The date and time the changeset was closed.
   * This will be null if the changeset is still open.
   */
  final DateTime? closedAt;

  /**
   * The user who created this changeset.
   */
  final OSMUser user;

  /**
   * The bounding box containing all the changes of this changeset.
   * If the changeset doesn't have any changes yet in other words [changesCount] is [0] this property will be null.
   */
  final BoundingBox? bbox;

  /**
   * The number of changes this changeset contains.
   */
  final int changesCount;

  /**
   * The number of comments in this changeset.
   */
  final int commentsCount;

  /**
   * An optional [List] of [OSMComment]s containing the discussion of this changeset.
   *
   * The [discussion] property is null if the discussion wasn't requested from the server, otherwise it's a [List] of zero ore more items.
   */
  final List<OSMComment>? discussion;

  /**
   * A short version for checking whether this chageset is still open.
   */
  bool get isOpen {
    return closedAt == null;
  }

  /**
   * A short version for checking whether this chageset has been closed.
   */
  bool get isClosed {
    return closedAt != null;
  }


  OSMChangeset({
    required this.id,
    required this.tags,
    required this.createdAt,
    this.closedAt,
    required this.user,
    this.bbox,
    required this.changesCount,
    required this.commentsCount,
    this.discussion
  });


  /**
   * A factory method for constructing an [OSMChangeset] from an XML [String].
   */
  static OSMChangeset fromXMLString(String xmlString) {
    var xmlDoc = XmlDocument.parse(xmlString);
    var changesetElement = xmlDoc.findAllElements('changeset').first;
    return fromXMLElement(changesetElement);
  }


  /**
   * A factory method for constructing an [OSMChangeset] object from an [XmlElement].
   */
  static OSMChangeset fromXMLElement(XmlElement changesetElement) {

    late int id;
    var tags = <String, String>{};
    late DateTime createdAt;
    DateTime? closedAt;
    late OSMUser user;
    late int changesCount;
    late int commentsCount;
    BoundingBox? bbox;
    List<OSMComment>? comments;

    // try parsing the xml attributes
    try {
      var idValue = changesetElement.getAttribute('id');
      id = int.parse(idValue!);

      var createdAtValue = changesetElement.getAttribute('created_at');
      createdAt = DateTime.parse(createdAtValue!);

      var closedAtValue = changesetElement.getAttribute('closed_at');
      if (closedAtValue != null) {
        closedAt = DateTime.parse(closedAtValue);
      }

      var userName = changesetElement.getAttribute('user')!;
      var uidValue = changesetElement.getAttribute('uid');
      var uid = int.parse(uidValue!);
      user = OSMUser(uid, userName);

      var changesCountValue = changesetElement.getAttribute('changes_count');
      changesCount = int.parse(changesCountValue!);

      var commentsCountValue = changesetElement.getAttribute('comments_count');
      commentsCount = int.parse(commentsCountValue!);

      var minLatValue = changesetElement.getAttribute('min_lat');
      var maxLatValue = changesetElement.getAttribute('max_lat');
      var minLonValue = changesetElement.getAttribute('min_lon');
      var maxLonValue = changesetElement.getAttribute('max_lon');

      if (minLatValue != null && maxLatValue != null && minLonValue != null && maxLonValue != null) {
        bbox = BoundingBox(
          double.parse(minLonValue),
          double.parse(minLatValue),
          double.parse(maxLonValue),
          double.parse(maxLatValue)
        );
      }
    }
    catch (e) {
      throw('Could not parse the given changeset XML string.');
    }

    changesetElement.findElements('tag').forEach((tag) {
      var k = tag.getAttribute('k');
      var v = tag.getAttribute('v');

      if (k != null && v != null) {
        tags[k] = v;
      }
    });

    var discussionElement = changesetElement.getElement('discussion');
    if (discussionElement != null) {
      comments = [];

      discussionElement.childElements.forEach((comment) {
        var date = comment.getAttribute('date');
        var uid = comment.getAttribute('uid');
        var userName = comment.getAttribute('user');
        var textElement = comment.getElement('text');

        if (date != null && uid != null && userName != null && textElement != null) {
          comments!.add(OSMComment(
            DateTime.parse(date),
            OSMUser(int.parse(uid), userName),
            textElement.text
          ));
        }
      });
    }

    return OSMChangeset(
      id: id,
      tags: tags,
      createdAt: createdAt,
      closedAt: closedAt,
      user: user,
      changesCount: changesCount,
      commentsCount: commentsCount,
      bbox: bbox,
      discussion: comments
    );
  }


  @override
  String toString() =>
    '$runtimeType - id: $id; '
    'tags: $tags; '
    'createdAt: $createdAt; '
    'closedAt: $closedAt; '
    'user: $user; '
    'bbox: $bbox; '
    'changesCount: $changesCount; '
    'commentsCount: $commentsCount; '
    'discussion: $discussion';


  @override
  int get hashCode =>
    id.hashCode ^
    tags.hashCode ^
    createdAt.hashCode ^
    closedAt.hashCode ^
    user.hashCode ^
    bbox.hashCode ^
    changesCount.hashCode ^
    commentsCount.hashCode ^
    discussion.hashCode;


  @override
  bool operator == (o) =>
    identical(this, o) ||
    o is OSMChangeset &&
    runtimeType == o.runtimeType &&
    id == o.id &&
    MapEquality().equals(tags, o.tags) &&
    createdAt == o.createdAt &&
    closedAt == o.closedAt &&
    user == o.user &&
    bbox == o.bbox &&
    changesCount == o.changesCount &&
    commentsCount == o.commentsCount &&
    ListEquality().equals(discussion, o.discussion);
}